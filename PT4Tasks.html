<!-- Programming Taskbook 4.8 | Copyright (c) M. Abramyan, 1998-2009 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>PT4Tasks</title>
<style type="text/css">
H1{font-family:"Arial";font-size:20pt;text-indent:0px;margin-top:10px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
H2{font-family:"Arial";font-size:16pt;text-indent:0px;margin-top:5px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
P{font-family:"Times New Roman";text-align:left;font-size:12pt;text-indent:0px;margin-top:0px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
TD{font-family:"Times New Roman";font-size:12pt;}
LI{font-family:"Times New Roman";font-size:12pt;}
UL{font-family:"Times New Roman";font-size:12pt;}
SUB{font-family:"Times New Roman";font-size:8pt;}
SUP{font-family:"Times New Roman";font-size:8pt;}
TABLE{margin-top:0px; margin-bottom:0px;}
P.ptAuthor{text-align:right;font-size:10pt;font-style:italic;}
P.ptTask{text-align:justify;text-indent:-50px;margin-top:5px; margin-left:60px;}
P.ptTaskQuote{text-align:left;margin-left:120px;margin-top:0px;margin-bottom:0px;}
P.ptTaskCenter{text-align:center;margin-left:60px;margin-top:0px;margin-bottom:0px;}
P.ptTaskContinue{text-align:justify;margin-left:60px;}
P.ptComment{text-align:justify;text-indent:50px;margin-top:5px;}
P.ptCommentCenter{text-align:center;}
P.ptCommentQuote{text-align:left;margin-left:120px;margin-top:0px;margin-bottom:0px;}
P.ptCommentContinue{text-align:justify;}
P.ptFooter{text-align:right;font-size:10pt;font-style:italic;margin-right:0px;}
SPAN.ptSpecial{font-family:"Arial";}
PRE{font-family:"Courier New";text-align:left;font-size:10pt;text-indent:0px;margin-top:5px; margin-right:10px; margin-bottom:0px; margin-left:60px;}
CODE{font-size:10pt;}
TT{font-size:10pt;}
P.ptPicture{font-family:Arial, sans-serif;margin-top: 5px;margin-bottom: 5px;margin-left: 60px;font-size: small;color: #000080;text-indent: 0pt;text-align: justify}
</style>
</head><body>
<h1>Введение в&nbsp;библиотеку MPI</h1>
<p class="ptAuthor">Автор: М.&nbsp;Э.&nbsp;Абрамян, 2010</p>
<p class="ptComment"> Если количество процессов в задании не определено, то можно считать, что это количество не превосходит&nbsp;12. Под <i>главным процессом</i> всюду в формулировках заданий понимается процесс ранга&nbsp;0 для коммуникатора MPI_COMM_WORLD. Для всех процессов ненулевого ранга в заданиях используется общее наименование <i>подчиненных процессов</i>. </p><p class="ptComment">Если в задании не указан тип обрабатываемых чисел, то числа считаются вещественными. Если в задании не определяется максимальный размер набора чисел, то его следует считать равным&nbsp;10.</p>
<h2>Процессы и&nbsp;их&nbsp;ранги</h2>
<p class="ptTask"><span class="ptSpecial">MPIBegin4°</span>. В подчиненных процессах четного ранга ввести целое число, в процессах нечетного ранга ввести вещественное число. В каждом подчиненном процессе вывести удвоенное значение введенного числа. В главном процессе не выполнять никаких действий. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin5°</span>. В каждом процессе дано целое число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел. В процессах четного ранга (включая главный) вывести сумму чисел из данного набора, в процессах нечетного ранга вывести среднее арифметическое чисел из данного набора. </p>
<h2>Обмен сообщениями между отдельными процессами</h2>
<p class="ptTask"><span class="ptSpecial">MPIBegin9°</span>. В каждом подчиненном процессе даны четыре целых числа. Переслать эти числа в главный процесс, используя по одному вызову функции MPI_Send для каждого передающего процесса, и вывести их в главном процессе. Полученные числа выводить в порядке возрастания рангов переславших их процессов. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin13°</span>. В главном процессе дано целое число&nbsp;<i>N</i> и набор из <i>N</i>&nbsp;чисел; <i>K</i>&nbsp;&#8722;&nbsp;1&nbsp;&#8804;&nbsp;<i>N</i>&nbsp;&lt;&nbsp;10, где <i>K</i>&nbsp;&#8212; количество процессов. С помощью функции MPI_Send переслать по одному числу их данного набора в процессы&nbsp;1, 2,&nbsp;&#8230;, <i>K</i>&nbsp;&#8722;&nbsp;2, а оставшиеся числа&nbsp;&#8212; в процесс&nbsp;<i>K</i>&nbsp;&#8722;&nbsp;1, и вывести полученные числа. В процессе&nbsp;<i>K</i>&nbsp;&#8722;&nbsp;1 для определения количества полученных чисел использовать функцию MPI_Get_count. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin16°</span>. В каждом подчиненном процессе дано целое число&nbsp;<i>N</i>, в главном процессе дано целое число&nbsp;<i>K</i> (&gt;&nbsp;0), равное количеству тех подчиненных процессов, в которых даны положительные числа&nbsp;<i>N</i>. Переслать все положительные числа&nbsp;<i>N</i> в главный процесс и вывести в нем сумму полученных чисел. Для приема сообщений в главном процессе использовать функцию MPI_Recv с параметром MPI_ANY_SOURCE. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin20°</span>. В каждом процессе даны два целых числа. С помощью функций MPI_Send и MPI_Recv переслать первое число в предыдущий процесс, а второе&nbsp;&#8212; в последующий процесс (для процесса&nbsp;0 считать предыдущим последний процесс, а для последнего процесса считать последующим процесс&nbsp;0). В каждом процессе вывести числа, полученные от предыдущего и последующего процесса (в указанном порядке). </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin21°</span>. В каждом процессе даны два числа: вещественное&nbsp;<i>A</i> и целое&nbsp;<i>N</i>, причем набор чисел&nbsp;<i>N</i> содержит все значения от&nbsp;0 до&nbsp;<i>K</i>&nbsp;&#8722;&nbsp;1, где <i>K</i>&nbsp;&#8212; количество процессов. Используя функции MPI_Send и MPI_Recv (с параметром MPI_ANY_SOURCE), выполнить в каждом процессе пересылку числа&nbsp;<i>A</i> в процесс&nbsp;<i>N</i> и вывести полученное число, а также ранг процесса, из которого число было получено. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin24°</span>. Количество процессов&nbsp;&#8212; четное число. В каждом процессе дано целое число&nbsp;<i>N</i> (0&nbsp;&lt;&nbsp;<i>N</i>&nbsp;&lt;&nbsp;5) и набор из <i>N</i>&nbsp;чисел. С помощью функции MPI_Sendrecv выполнить обмен исходными наборами между парами процессов&nbsp;0 и&nbsp;1, 2 и&nbsp;3, и т.&nbsp;д. В каждом процессе вывести полученный набор чисел. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin26°</span>. В каждом подчиненном процессе дано вещественное число&nbsp;<i>A</i> и его порядковый номер&nbsp;<i>N</i> (целое число); набор всех номеров&nbsp;<i>N</i> содержит все целые числа от&nbsp;1 до&nbsp;<i>K</i>&nbsp;&#8722;&nbsp;1, где <i>K</i>&nbsp;&#8212; количество процессов. Переслать числа&nbsp;<i>A</i> в главный процесс и вывести их в порядке, соответствующем возрастанию их номеров&nbsp;<i>N</i>. Для передачи номера&nbsp;<i>N</i> указывать его в качестве параметра msgtag функции MPI_Send. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin28°</span>. В главном процессе дан набор пар чисел (<i>T</i>, <i>A</i>); количество пар равно числу подчиненных процессов. Число&nbsp;<i>T</i>&nbsp;&#8212; целое, равное&nbsp;0 или&nbsp;1. Число&nbsp;<i>A</i>&nbsp;&#8212; целое, если <i>T</i>&nbsp;=&nbsp;0, и вещественное, если <i>T</i>&nbsp;=&nbsp;1. Переслать по одному числу&nbsp;<i>A</i> в каждый из подчиненных процессов (первое число в процесс&nbsp;1, второе&nbsp;&#8212; в процесс&nbsp;2, и т.&nbsp;д.) и вывести полученные числа. Для передачи информации о типе пересланного числа указывать число&nbsp;<i>T</i> в качестве параметра msgtag функции MPI_Send, для получения этой информации использовать функцию MPI_Probe с параметром MPI_ANY_TAG. </p>
<h2>Коллективная пересылка данных</h2>
<p class="ptTask"><span class="ptSpecial">MPIBegin30°</span>. В главном процессе дано целое число. Используя функцию MPI_Bcast, переслать это число во все подчиненные процессы и вывести в них полученное число. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin36°</span>. В главном процессе дан набор из 3<i>K</i> чисел, где <i>K</i>&nbsp;&#8212; количество процессов. Используя функцию MPI_Scatter, переслать по 3&nbsp;числа в каждый процесс (включая главный) и вывести в каждом процессе полученные числа. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin39°</span>. В главном процессе дан набор из <i>K</i>&nbsp;+&nbsp;2 чисел, где <i>K</i>&nbsp;&#8212; количество процессов. Используя функцию MPI_Scatterv, переслать в каждый процесс три числа из данного набора; при этом в процесс ранга&nbsp;<i>R</i> должны быть пересланы числа с номерами от <i>R</i>&nbsp;+&nbsp;1 до <i>R</i>&nbsp;+&nbsp;3 (в процесс&nbsp;0&nbsp;&#8212; первые три числа, в процесс&nbsp;1&nbsp;&#8212; числа со второго по четвертое, и т.&nbsp;д.). В каждом процессе вывести полученные числа. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin40°</span>. В каждом процессе дано вещественное число. Используя функцию MPI_Allgather, переслать эти числа во все процессы и вывести их в каждом процессе в порядке возрастания рангов переславших их процессов (включая число, полученное из этого же процесса). </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin43°</span>. В каждом процессе дан набор из <i>K</i>&nbsp;чисел, где <i>K</i>&nbsp;&#8212; количество процессов. Используя функцию MPI_Alltoall, переслать в каждый процесс по одному числу из всех наборов: в процесс&nbsp;0&nbsp;&#8212; первые числа из наборов, в процесс&nbsp;1&nbsp;&#8212; вторые числа, и т.&nbsp;д. В каждом процессе вывести числа в порядке возрастания рангов переславших их процессов (включая число, полученное из этого же процесса). </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin45°</span>. В каждом процессе дан набор из <i>K</i>(<i>K</i>&nbsp;+&nbsp;1)/2 целых чисел, где <i>K</i>&nbsp;&#8212; количество процессов. Используя функцию MPI_Alltoallv, переслать в каждый процесс часть чисел из каждого набора; при этом в процесс&nbsp;<i>R</i> должно быть переслано <i>R</i>&nbsp;+&nbsp;1&nbsp;очередное число (в процесс&nbsp;0&nbsp;&#8212; первое число каждого набора, в процесс&nbsp;1&nbsp;&#8212; следующие два числа, и т.&nbsp;д.). В каждом процессе вывести полученные числа. </p>
<h2>Коллективные операции редукции</h2>
<p class="ptTask"><span class="ptSpecial">MPIBegin48°</span>. В каждом процессе дан набор из <i>K</i>&nbsp;+&nbsp;5 целых чисел, где <i>K</i>&nbsp;&#8212; количество процессов. Используя функцию MPI_Reduce для операции MPI_SUM, просуммировать элементы данных наборов с одним и тем же порядковым номером и вывести полученные суммы в главном процессе. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin51°</span>. В каждом процессе дан набор из <i>K</i>&nbsp;+&nbsp;5 чисел, где <i>K</i>&nbsp;&#8212; количество процессов. Используя функцию MPI_Allreduce для операции MPI_PROD, перемножить элементы данных наборов с одним и тем же порядковым номером и вывести полученные произведения во всех процессах. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin54°</span>. В каждом процессе дан набор из 2<i>K</i>&nbsp;чисел, где <i>K</i>&nbsp;&#8212; количество процессов. Используя функцию MPI_Reduce_scatter, найти максимумы среди элементов этих наборов с одним и тем же порядковым номером, переслать по два найденных максимума в каждый процесс (первые два максимума&nbsp;&#8212; в процесс&nbsp;0, следующие два&nbsp;&#8212; в процесс&nbsp;1, и т.&nbsp;д.) и вывести в каждом процессе полученные данные. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin57°</span>. В каждом процессе дан набор из <i>K</i>&nbsp;+&nbsp;5 целых чисел, где <i>K</i>&nbsp;&#8212; количество процессов. Используя функцию MPI_Scan, найти в процессе ранга&nbsp;<i>R</i> (<i>R</i>&nbsp;=&nbsp;0, &#8230;,&nbsp;<i>K</i>&nbsp;&#8722;&nbsp;1) максимальные значения среди элементов с одним и тем же порядковым номером для наборов, данных в процессах с рангами от&nbsp;0 до&nbsp;<i>R</i>, и вывести в каждом процессе найденные максимумы. </p>
<h2>Производные типы и&nbsp;упаковка данных</h2>
<p class="ptTask"><span class="ptSpecial">MPIBegin59°</span>. В главном процессе дана <i>K</i>&nbsp;&#8722;&nbsp;1&nbsp;тройка целых чисел, где <i>K</i>&nbsp;&#8212; количество процессов. Используя производный тип, содержащий три целых числа, и одну коллективную операцию пересылки данных, переслать по одной тройке чисел в каждый из подчиненных процессов и вывести их в подчиненных процессах в том же порядке. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin61°</span>. В главном процессе дана <i>K</i>&nbsp;&#8722;&nbsp;1&nbsp;тройка чисел, где <i>K</i>&nbsp;&#8212; количество процессов, причем первые два числа каждой тройки являются целыми, а третье число&nbsp;&#8212; вещественным. Используя производный тип, содержащий три числа (два целых и одно вещественное), переслать числа из главного процесса в подчиненные и вывести их в подчиненных процессах в том же порядке. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin65°</span>. В каждом подчиненном процессе даны <i>R</i>&nbsp;троек чисел, где <i>R</i>&nbsp;&#8212; ранг процесса. Два первых числа в каждой тройке являются целыми, а последнее&nbsp;&#8212; вещественным. Используя производный тип, содержащий три числа (два целых и одно вещественное), переслать числа из подчиненных процессов в главный и вывести полученные числа в порядке возрастания рангов переславших их процессов. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin66°</span>. В главном процессе даны два набора: первый содержит <i>K</i>&nbsp;целых, а второй <i>K</i>&nbsp;вещественных чисел, где <i>K</i>&nbsp;&#8212; количество процессов. Используя функции упаковки MPI_Pack и MPI_Unpack и одну коллективную операцию пересылки данных, переслать все данные из главного процесса в подчиненные и вывести их в подчиненных процессах в том же порядке. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin70°</span>. В каждом подчиненном процессе дан набор из одного вещественного и <i>R</i>&nbsp;целых чисел, где значение&nbsp;<i>R</i> равно рангу процесса (в процессе 1 дано одно целое число, в процессе 2&nbsp;&#8212; два целых числа, и т.&nbsp;д.). Используя функции упаковки и одну функцию передачи и приема, переслать все данные в главный процесс и вывести эти данные в порядке возрастания рангов переславших их процессов. </p>
<h2>Группы процессов и&nbsp;коммуникаторы</h2>
<p class="ptTask"><span class="ptSpecial">MPIBegin72°</span>. В каждом процессе нечетного ранга (1,&nbsp;3,&nbsp;&#8230;) даны два вещественных числа. С помощью функций MPI_Comm_group, MPI_Group_excl и MPI_Comm_create создать новый коммуникатор, включающий процессы нечетного ранга. Используя одну коллективную операцию пересылки данных для созданного коммуникатора, переслать исходные числа во все процессы нечетного ранга и вывести эти числа в порядке возрастания рангов переславших их процессов (включая числа, полученные из этого же процесса). </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin75°</span>. В каждом процессе дано вещественное число. Используя функцию MPI_Comm_split и одну коллективную операцию редукции, найти максимальное из чисел, данных в процессах с четным рангом (включая главный процесс), и минимальное из чисел, данных в процессах с нечетным рангом. Найденный максимум вывести в процессе&nbsp;0, а найденный минимум&nbsp;&#8212; в процессе&nbsp;1. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin77°</span>. В каждом процессе дано целое число&nbsp;<i>N</i>, которое может принимать два значения:&nbsp;0 и&nbsp;1 (имеется хотя бы один процесс с <i>N</i>&nbsp;=&nbsp;1). Кроме того, в каждом процессе с <i>N</i>&nbsp;=&nbsp;1 дано вещественное число&nbsp;<i>A</i>. Используя функцию MPI_Comm_split и одну коллективную операцию пересылки данных, переслать числа&nbsp;<i>A</i> в первый из процессов с <i>N</i>&nbsp;=&nbsp;1 и вывести их в порядке возрастания рангов переславших их процессов (включая число, полученное из этого же процесса). </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin79°</span>. В каждом процессе дано целое число&nbsp;<i>N</i>, которое может принимать два значения:&nbsp;0 и&nbsp;1 (имеется хотя бы один процесс с <i>N</i>&nbsp;=&nbsp;1). Кроме того, в каждом процессе с <i>N</i>&nbsp;=&nbsp;1 дано вещественное число&nbsp;<i>A</i>. Используя функцию MPI_Comm_split и одну коллективную операцию пересылки данных, переслать числа&nbsp;<i>A</i> во все процессы с <i>N</i>&nbsp;=&nbsp;1 и вывести их в порядке возрастания рангов переславших их процессов (включая число, полученное из этого же процесса). </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin80°</span>. В каждом процессе дано целое число&nbsp;<i>N</i>, которое может принимать два значения: 1 и&nbsp;2 (имеется хотя бы один процесс с каждым из возможных значений). Кроме того, в каждом процессе дано целое число&nbsp;<i>A</i>. Используя функцию MPI_Comm_split и одну коллективную операцию пересылки данных, переслать числа&nbsp;<i>A</i>, данные в процессах с <i>N</i>&nbsp;=&nbsp;1, во все процессы с <i>N</i>&nbsp;=&nbsp;1, а числа&nbsp;<i>A</i>, данные в процессах с <i>N</i>&nbsp;=&nbsp;2, во все процессы с <i>N</i>&nbsp;=&nbsp;2. Во всех процессах вывести полученные числа в порядке возрастания рангов переславших их процессов (включая число, полученное из этого же процесса). </p>
<h2>Виртуальные топологии</h2>
<p class="ptTask"><span class="ptSpecial">MPIBegin83°</span>. В главном процессе дано целое число&nbsp;<i>N</i> (&gt;&nbsp;1), причем известно, что количество процессов&nbsp;<i>K</i> делится на&nbsp;<i>N</i>. Переслать число&nbsp;<i>N</i> во все процессы, после чего, используя функцию MPI_Cart_create, определить для всех процессов декартову топологию в виде двумерной решетки&nbsp;&#8212; матрицы размера <i>N</i>&nbsp;&#215;&nbsp;<i>K</i>/<i>N</i> (порядок нумерации процессов оставить прежним). Используя функцию MPI_Cart_coords, вывести для каждого процесса его координаты в созданной топологии. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin85°</span>. Число процессов&nbsp;<i>К</i> является четным: <i>K</i>&nbsp;=&nbsp;2<i>N</i>, <i>N</i>&nbsp;&gt;&nbsp;1. В процессах&nbsp;0 и&nbsp;<i>N</i> дано по одному вещественному числу&nbsp;<i>A</i>. Определить для всех процессов декартову топологию в виде матрицы размера 2&nbsp;&#215;&nbsp;<i>N</i>, после чего, используя функцию MPI_Cart_sub, расщепить матрицу процессов на две одномерные строки (при этом процессы&nbsp;0 и&nbsp;<i>N</i> будут главными процессами в полученных строках). Используя одну коллективную операцию пересылки данных, переслать число&nbsp;<i>A</i> из главного процесса каждой строки во все процессы этой же строки и вывести полученное число в каждом процессе (включая процессы&nbsp;0 и&nbsp;<i>N</i>). </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin92°</span>. Количество процессов&nbsp;<i>K</i> равно&nbsp;8 или 12, в каждом процессе дано вещественное число. Определить для всех процессов декартову топологию в виде трехмерной решетки размера 2&nbsp;&#215;&nbsp;2&nbsp;&#215;&nbsp;<i>K</i>/4 (порядок нумерации процессов оставить прежним). Интерпретируя полученную решетку как <i>K</i>/4 матриц размера 2&nbsp;&#215;&nbsp;2 (в одну матрицу входят процессы с одинаковой третьей координатой), расщепить эту решетку на <i>K</i>/4 указанных матриц. Используя одну коллективную операцию редукции, для каждой из полученных матриц найти сумму исходных чисел и вывести найденные суммы в каждом процессе соответствующей матрицы. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin94°</span>. В главном процессе даны положительные целые числа&nbsp;<i>M</i> и&nbsp;<i>N</i>, произведение которых не превосходит количества процессов; кроме того, в процессах с рангами от&nbsp;0 до&nbsp;<i>M</i>&#183;<i>N</i>&nbsp;&#8722;&nbsp;1 даны целые числа&nbsp;<i>X</i> и&nbsp;<i>Y</i>. Переслать числа&nbsp;<i>M</i> и&nbsp;<i>N</i> во все процессы, после чего определить для начальных <i>M</i>&#183;<i>N</i>&nbsp;процессов декартову топологию в виде двумерной решетки размера <i>M</i>&nbsp;&#215;&nbsp;<i>N</i>, являющейся периодической по второму измерению (порядок нумерации процессов оставить прежним). В каждом процессе, входящем в созданную топологию, вывести ранг процесса с координатами <i>X</i>,&nbsp;<i>Y</i> (с учетом периодичности), используя для этого функцию MPI_Cart_rank. В случае недопустимых координат вывести&nbsp;&#8722;1. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin96°</span>. Число процессов&nbsp;<i>К</i> является четным: <i>K</i>&nbsp;=&nbsp;2<i>N</i>, <i>N</i>&nbsp;&gt;&nbsp;1; в каждом процессе дано вещественное число&nbsp;<i>A</i>. Определить для всех процессов декартову топологию в виде матрицы размера 2&nbsp;&#215;&nbsp;<i>N</i> (порядок нумерации процессов оставить прежним) и для каждой строки матрицы осуществить циклический сдвиг исходных данных с шагом&nbsp;1 (число&nbsp;<i>A</i> из каждого процесса, кроме последнего в строке, пересылается в следующий процесс этой же строки, а из последнего процесса&nbsp;&#8212; в главный процесс этой строки). Для определения рангов посылающих и принимающих процессов использовать функцию MPI_Cart_shift, пересылку выполнять с помощью функции MPI_Sendrecv. Во всех процессах вывести полученные данные. </p>
<p class="ptTask"><span class="ptSpecial">MPIBegin100°</span>. Количество процессов&nbsp;<i>K</i> равно&nbsp;3<i>N</i>&nbsp;+&nbsp;1 (1&nbsp;&lt;&nbsp;<i>N</i>&nbsp;&lt;&nbsp;5); в каждом процессе дано целое число&nbsp;<i>A</i>. Используя функцию MPI_Graph_create, определить для всех процессов топологию графа, в которой процессы&nbsp;<i>R</i>, <i>R</i>&nbsp;+&nbsp;1, <i>R</i>&nbsp;+&nbsp;2, где <i>R</i>&nbsp;=&nbsp;1,&nbsp;4, 7,&nbsp;&#8230;, связаны между собой ребрами, и, кроме того, каждый процесс положительного ранга, кратного трем (3, 6,&nbsp;&#8230;), связан ребром с главным процессом (в результате получается <i>N</i>-лучевая звезда, центром которой является главный процесс, а каждый луч состоит из трех связанных между собой процессов, причем с центром связан процесс ранга, кратного трем). Переслать число&nbsp;<i>A</i> из каждого процесса всем процессам-соседям. Для определения количества процессов-соседей и их рангов использовать функции MPI_Graph_neighbors_count и MPI_Graph_neighbors, пересылку выполнять с помощью функции MPI_Sendrecv. Во всех процессах вывести полученные числа в порядке возрастания рангов переславших их процессов. </p>
<h1>Знакомство с&nbsp;технологией OpenMP</h1>
<p class="ptAuthor">Автор: М.&nbsp;Э.&nbsp;Абрамян, 2014</p>
<h2>Обработка вложенных циклов</h2>
<p class="ptComment"> </p><p class="ptComment">При выполнении заданий необходимо не только вывести требуемые результаты, но и отобразить дополнительную информацию в разделе отладки окна задачника, используя функции Show и ShowLine: время работы непараллельного варианта алгоритма (<tt>Non-parallel time</tt>), количество процессоров (<tt>num_procs</tt>), количество потоков в параллельном варианте алгоритма (<tt>num_threads</tt>), количество слагаемых внутренних сумм, вычисленных в каждом потоке, и время, использованное на вычисления (указывается номер потока <tt>thread_num</tt>, количество слагаемых <tt>Count</tt> и время <tt>Thread time</tt>), общее время работы параллельного варианта алгоритма (<tt>Total parallel time</tt>), ускорение параллельного варианта по сравнению с непараллельным (<tt>Rate</tt>, вычисляется как отношение времени работы непараллельного варианта к общему времени работы параллельного варианта). Время выводится в миллисекундах. </p><p class="ptComment">Пример содержимого раздела отладки: </p><p class="ptCommentQuote"><tt>1&gt;  Non-parallel time: 350.87</tt><br><tt>2&gt;  num_procs: 2</tt><br><tt>3&gt;  num_threads: 2</tt><br><tt>4&gt;  thread_num: 1 Count: 2471976 Thread time: 165.48</tt><br><tt>5&gt;  thread_num: 0 Count: 2471964 Thread time: 167.14</tt><br><tt>6&gt;  Total parallel time: 168.53</tt><br><tt>7&gt;  Rate: 2.08</tt></p><p class="ptCommentContinue"></p><p class="ptComment">При выводе данных в параллельных разделах программы следует использовать директивы master и critical. Значение <tt>Thread time</tt> не должно включать время, использованное в каждом потоке для вывода информации.</p>
<p class="ptTask"><span class="ptSpecial">OMPBegin1°</span>. Реализовать два варианта вычисления функции <i>F</i>(<i>X</i>,&nbsp;<i>N</i>): непараллельный и параллельный низкоуровневый, использующий функцию omp_get_thread_num() (число потоков равно 2). Формула для функции <i>F</i>: </p><p class="ptTaskCenter"><i>F</i>(<i>X</i>,&nbsp;<i>N</i>)&nbsp;=&nbsp;&#931;<sup><i>N</i></sup><sub><i>I</i>=1</sub>&nbsp;1/(&#931;<sup><i>I</i></sup><sub><i>J</i>=1</sub>&nbsp;(<i>J</i>&nbsp;+&nbsp;(<i>X</i>&nbsp;+&nbsp;<i>J</i>)<sup>1/3</sup>)/(2<i>I</i><i>J</i>&nbsp;&#8722;&nbsp;1))</p><p class="ptTaskContinue">В разделе отладки вывести дополнительную информацию, описание которой приведено в преамбуле к данной группе заданий. Обеспечить возможно большее ускорение параллельного варианта за счет равномерной загрузки потоков. Для этого использовать алгоритм распределения слагаемых по <i>полосам</i>, вычисляя все слагаемые с четными значениями <i>I</i> в одном из потоков, а все слагаемые с нечетными значениями <i>I</i> &#8212; в другом. </p>
<p class="ptTask"><span class="ptSpecial">OMPBegin5°</span>. Реализовать два варианта вычисления функции <i>F</i>(<i>X</i>,&nbsp;<i>N</i>): непараллельный и параллельный низкоуровневый, использующий функцию omp_get_thread_num() (число потоков равно 4). Формула для функции <i>F</i>: </p><p class="ptTaskCenter"><i>F</i>(<i>X</i>,&nbsp;<i>N</i>)&nbsp;=&nbsp;&#931;<sup><i>N</i></sup><sub><i>I</i>=1</sub>&nbsp;1/(&#931;<sup><i>I</i></sup><sub><i>J</i>=1</sub>&nbsp;(<i>J</i>&nbsp;+&nbsp;sin(<i>X</i>&nbsp;+&nbsp;<i>J</i>))/(2<i>I</i><i>J</i>&nbsp;&#8722;&nbsp;1))</p><p class="ptTaskContinue">В разделе отладки вывести дополнительную информацию, описание которой приведено в преамбуле к данной группе заданий. Обеспечить возможно большее ускорение параллельного варианта за счет равномерной загрузки потоков. Для этого использовать алгоритм распределения слагаемых по <i>обратным полосам</i>, разбивая набор значений <i>I</i> на полосы шириной 8 и распределяя их обработку следующим образом: в потоке 0 обрабатывается первый и последний элемент каждой полосы, в потоке 1 &#8212; второй и предпоследний элемент, и т.&nbsp;д. (в последнем потоке обрабатываются два средних элемента каждой полосы). Считать, что для параллельного варианта вычисления функции число <i>N</i> кратно&nbsp;8. </p>
<p class="ptTask"><span class="ptSpecial">OMPBegin9°</span>. Реализовать два варианта вычисления функции <i>F</i>(<i>X</i>,&nbsp;<i>N</i>): непараллельный и параллельный, основанный на использовании директив sections и section (число потоков равно 2). Формула для функции <i>F</i>: </p><p class="ptTaskCenter"><i>F</i>(<i>X</i>,&nbsp;<i>N</i>)&nbsp;=&nbsp;&#931;<sup><i>N</i></sup><sub><i>I</i>=1</sub>&nbsp;1/(&#931;<sup><i>I</i></sup><sub><i>J</i>=1</sub>&nbsp;(<i>J</i>&nbsp;+&nbsp;ln(1&nbsp;+&nbsp;<i>X</i>&nbsp;+&nbsp;<i>J</i>))/(2<i>I</i><i>J</i>&nbsp;&#8722;&nbsp;1))</p><p class="ptTaskContinue">В разделе отладки вывести дополнительную информацию, описание которой приведено в преамбуле к данной группе заданий. Обеспечить возможно большее ускорение параллельного варианта за счет равномерной загрузки потоков. Для этого разбить внешнюю сумму на две части (с диапазонами значений 1..<i>K</i> и <i>K</i>+1..<i>N</i> параметра <i>I</i>), содержащие примерно одинаковое количество слагаемых внутренних сумм. При указании диапазонов значений параметра <i>I</i> использовать формулу, выражающую зависимость <i>K</i> от&nbsp;<i>N</i>. Для вывода формулы воспользоваться соотношениями между площадями соответствующих геометрических фигур (прямоугольных треугольников или прямоугольных трапеций), получив в результате квадратное уравнение относительно неизвестной&nbsp;<i>K</i>. </p>
<p class="ptTask"><span class="ptSpecial">OMPBegin13°</span>. Реализовать два варианта вычисления функции <i>F</i>(<i>X</i>,&nbsp;<i>N</i>): непараллельный и параллельный, основанный на использовании директив sections и section (число потоков равно 4). Формула для функции <i>F</i>: </p><p class="ptTaskCenter"><i>F</i>(<i>X</i>,&nbsp;<i>N</i>)&nbsp;=&nbsp;&#931;<sup><i>N</i></sup><sub><i>I</i>=1</sub>&nbsp;1/(&#931;<sup><i>I</i></sup><sub><i>J</i>=1</sub>&nbsp;(<i>J</i>&nbsp;+&nbsp;(<i>X</i>&nbsp;+&nbsp;<i>J</i>)<sup>1/4</sup>)/(2<i>I</i><i>J</i>&nbsp;&#8722;&nbsp;1))</p><p class="ptTaskContinue">В разделе отладки вывести дополнительную информацию, описание которой приведено в преамбуле к данной группе заданий. Обеспечить возможно большее ускорение параллельного варианта за счет равномерной загрузки потоков. Для этого разбить внешнюю сумму на четыре части (с диапазонами значений 1..<i>K</i><sub>1</sub>, <i>K</i><sub>1</sub>+1..<i>K</i><sub>2</sub>, <i>K</i><sub>2</sub>+1..<i>K</i><sub>3</sub> и <i>K</i><sub>3</sub>+1..<i>N</i> параметра <i>I</i>), содержащие примерно одинаковое количество слагаемых внутренних сумм. Значения <i>K</i><sub>1</sub>, <i>K</i><sub>2</sub>, <i>K</i><sub>3</sub> определить с помощью следующего вспомогательного алгоритма: вначале находится величина <i>K</i><sub>0</sub>&nbsp;=&nbsp;<i>K</i>&nbsp;/&nbsp;4, где <i>K</i> равно общему количеству слагаемых внутренних сумм; затем организуется перебор значений параметра <i>I</i>, в ходе которого в счетчике <i>C</i> накапливается общее количество слагаемых внутренних сумм, соответствующих перебираемым значениям <i>I</i>, пока значение <i>C</i> не превысит <i>K</i><sub>0</sub>, после чего текущее значение параметра <i>I</i> записывается в очередную из переменных <i>K</i><sub>1</sub>, <i>K</i><sub>2</sub>, <i>K</i><sub>3</sub>, а счетчик <i>C</i> сбрасывается в&nbsp;0. </p>
<p class="ptTask"><span class="ptSpecial">OMPBegin18°</span>. Реализовать два варианта вычисления функции <i>F</i>(<i>X</i>,&nbsp;<i>N</i>): непараллельный и параллельный, основанный на использовании статического варианта директивы for (число потоков равно 2). Формула для функции <i>F</i>: </p><p class="ptTaskCenter"><i>F</i>(<i>X</i>,&nbsp;<i>N</i>)&nbsp;=&nbsp;&#931;<sup><i>N</i></sup><sub><i>I</i>=1</sub>&nbsp;1/(&#931;<sup><i>I</i>+<i>N</i></sup><sub><i>J</i>=1</sub>&nbsp;(<i>J</i>&nbsp;+&nbsp;cos(<i>X</i>&nbsp;+&nbsp;<i>J</i>))/(2<i>I</i><i>J</i>&nbsp;&#8722;&nbsp;1))</p><p class="ptTaskContinue">В разделе отладки вывести дополнительную информацию, описание которой приведено в преамбуле к данной группе заданий. Обеспечить возможно большее ускорение параллельного варианта за счет равномерной загрузки потоков. </p>
<p class="ptTask"><span class="ptSpecial">OMPBegin24°</span>. Реализовать два варианта вычисления функции <i>F</i>(<i>X</i>,&nbsp;<i>N</i>): непараллельный и параллельный, основанный на использовании динамического варианта директивы for (число потоков равно 4). Формула для функции <i>F</i>: </p><p class="ptTaskCenter"><i>F</i>(<i>X</i>,&nbsp;<i>N</i>)&nbsp;=&nbsp;&#931;<sup><i>N</i></sup><sub><i>I</i>=1</sub>&nbsp;1/(&#931;<sup>2<i>N</i></sup><sub><i>J</i>=<i>I</i></sub>&nbsp;(<i>J</i>&nbsp;+&nbsp;(<i>X</i>&nbsp;+&nbsp;<i>J</i>)<sup>1/5</sup>)/(2<i>I</i><i>J</i>&nbsp;&#8722;&nbsp;1))</p><p class="ptTaskContinue">В разделе отладки вывести дополнительную информацию, описание которой приведено в преамбуле к данной группе заданий. Обеспечить возможно большее ускорение параллельного варианта за счет равномерной загрузки потоков. </p>
<hr noshade>
<p class="ptFooter">Дата генерации страницы: 10.03.2017.</p>
</body></html>
